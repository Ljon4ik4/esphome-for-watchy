## Watchy ##
# https://watchy.sqfmi.com/docs/hardware

substitutions:
  #### SECRETS ####
  <<: !include secrets.yaml
  #### PARAMS ####
  ID: "1"
  NAME: watchy$ID
  VERSION: "3"
  <<: !include pins_v3.yaml
  #### FACES AND MODES ####
  FACE_COUNT: "4"
  MODE_FACES: "0"
  MODE_TIMERS: "1"
  MODE_HA: "2"
  MODE_QR: "3"
  #### BATTERY ####
  BATTERY_FULL: "3.8"
  BATTERY_HIGH: "3.6"
  BATTERY_LOW: "3.2"
  #### ICONS ####
  <<: !include mdi.yaml

esphome:
  name: $NAME
  includes:
    # - mdi.h
    - icons.h
  on_boot:
    then:
      - delay: 1ms
      # - pcf8563.read_time:
      - component.update: battery
      - lambda: |-
          randomSeed(esp_random());
          const auto now = id(ntp).now();

          id(chime) = (now.hour ==  8 && now.minute == 0)
                   || (now.hour == 12 && now.minute == 0)
                   || (now.hour == 16 && now.minute == 0)
                   ;

          id(weather_age_hours) = (id(ntp).utcnow().timestamp - id(weather_age)) / (60*60);

          if (esp_sleep_get_wakeup_cause() != ESP_SLEEP_WAKEUP_TIMER) {
            ESP_LOGI("watchy", "Keep awake mode.");
            id(keep_awake) = true;
          }

          if ((now.hour % 3 == 0 && now.minute == 0) || esp_sleep_get_wakeup_cause() == ESP_SLEEP_WAKEUP_UNDEFINED) {
            ESP_LOGI("watchy", "Update weather.");
            id(updating_weather) = true;
            id(updating_time) = true;
            id(wifi_id).enable();
          } else if (!id(keep_awake) && id(mode) == $MODE_FACES) {
            if (random(1000) == 0) {
              id(chime) = true;
              id(mode) = id(mode) + 1000;
            }
          }

      - if:
          condition:
            lambda: return id(keep_awake) || id(chime);
          then:
            - switch.turn_on: buzzer
            - component.update: glass
            - switch.turn_off: buzzer
          else:
            - component.update: glass
      - script.execute: go_to_sleep

display:
  # Configuration for the display
  # https://esphome.io/components/display/
  # https://esphome.io/components/display/waveshare_epaper.html
  # https://www.good-display.com/product/206.html
  # https://www.e-paper-display.com/products_detail/productId=455.html
  - id: glass
    platform: waveshare_epaper
    model: 1.54inv2
    cs_pin: $DISPLAY_CS_PIN
    dc_pin: $DISPLAY_DC_PIN
    reset_pin: $DISPLAY_RES_PIN
    busy_pin: $DISPLAY_BUSY_PIN
    update_interval: never
    # Problem: full_update_every does not work as expected because esphome code will do a full update on every boot up.
    # Solution: Edited `waveshare_epaper.h` and initialise to 1 instead of 0: `uint32_t at_update_{1};`
    # See: `external_components` near the bottom.
    full_update_every: 1000
    # Duration for the display reset operation. Defaults to 200ms. Setting this value to 2ms may resolve issues with newer e-Paper Driver modules (e.g. Rev 2.1).
    reset_duration: 2ms # ?????
    lambda: |-
      auto w = it.get_width();
      auto h = it.get_height();

      const auto now = id(ntp).now();
      const auto utcnow = id(ntp).utcnow();

      const int m = now.month;
      const int d = now.day_of_month;
      const int md = m * 100 + d;
      const int FRIDAY = 6;

      const char *wifiIcon = id(wifi_id).is_disabled() ?
        (id(keep_awake) ? mdiEmoticonHappyOutline : "") :
        (id(wifi_id).is_connected() ? mdiWifi  : mdiWifiOff);

      const char *batteryIcon = id(is_charging).state ? mdiBatteryCharging100 : (
        !id(battery).has_state() ? mdiBatteryUnknown : (
          id(battery).state > $BATTERY_FULL ? mdiBattery : (
            id(battery).state > $BATTERY_HIGH ? mdiBattery70 : (
              id(battery).state > $BATTERY_LOW ? mdiBattery30 :
                mdiBattery10
            )
          )
        )
      );

      const char *chimeIcon = id(chime) ? mdiBellRingOutline : "";

      const char *calendarIcon = "";
      if (
        m == $BIRTHMONTH && d == $BIRTHDAY ||
        m == $BIRTHMONTH1 && d == $BIRTHDAY1 ||
        m == $BIRTHMONTH2 && d == $BIRTHDAY2
      ) {
        calendarIcon = mdiCakeVariantOutline;
      } else if (calendarIcons.find(md) != calendarIcons.end()) {
        calendarIcon = calendarIcons[md];
      } else if (now.day_of_year == 256) {
        calendarIcon = mdiCodeBraces;
      } else if (now.day_of_week == FRIDAY && d == 13) {
        calendarIcon = mdiClover;
      }

      if (id(mode) == $MODE_FACES) {
        if (id(face) == 0) {
          ////////// Digital Face //////////

          // Date //
          it.strftime(w/2, 0, id(date_font), TextAlign::TOP_CENTER, "%a %d %b", now);

          // Time //
          it.print(w/2, h/2-5, id(time_font), TextAlign::CENTER, ":");
          it.printf(w/2-10, h/2, id(time_font), TextAlign::CENTER_RIGHT, "%d", now.hour);
          it.printf(w/2+10, h/2, id(time_font), TextAlign::CENTER_LEFT, "%02d", now.minute);
          if (now.hour <= 9) {
            it.printf(0, h/2, id(mdi), TextAlign::CENTER_LEFT, "%s", calendarIcon);
          }

          // Weather //
          if (id(weather_temp_max) != -1000.0 && id(weather_age_hours) <= 12) {
            it.printf(0, h, id(date_font), TextAlign::BOTTOM_LEFT, "%.0f°", id(weather_temp_max));
          }

          if (id(weather_code_0) != 0) {
            it.printf(w, h, id(mdi), TextAlign::BOTTOM_RIGHT, "%s%s%s%s",
              id(weather_age_hours) <= 3 ? weatherIcons[id(weather_code_0)] : "",
              id(weather_age_hours) <= 6 ? weatherIcons[id(weather_code_1)] : "",
              id(weather_age_hours) <= 9 ? weatherIcons[id(weather_code_2)] : "",
              id(weather_age_hours) <= 12 ? weatherIcons[id(weather_code_3)] : ""
            );
          }

          // Status Icons //
          it.printf(w/2, h/2+46, id(mdi_small), TextAlign::CENTER, "%s%s%s", chimeIcon, wifiIcon, batteryIcon);

          // Active Timer //
          if (id(timers)[id(active_timer)] != 0) {
            int activeTimer = id(ntp).utcnow().timestamp - id(timers)[id(active_timer)];
            if (activeTimer < 100 * 60 * 60) { // Limit to 100 hours
              it.printf(w/2, h/2-46, id(small_font), TextAlign::CENTER,
                "%dh %02dm",
                (activeTimer) / (60*60),
                (activeTimer / 60) % 60
              );
            }
          }

        } else if (id(face) == 1 || id(face) == 2) {
          ////////// Hands Face //////////
          const bool n = id(face) == 1;

          // Center Dot //
          it.filled_circle(w/2, w/2, 5);

          // Big Marks //
          it.print(w, h/2, id(date_font), TextAlign::CENTER_RIGHT, n ? "3" : "III");
          it.print(w/2, h+6, id(date_font), TextAlign::BOTTOM_CENTER, n ? "6" : "VI");
          it.print(0, h/2, id(date_font), TextAlign::CENTER_LEFT, n ? "9" : "IX");
          it.print(w/2, 0-8, id(date_font), TextAlign::TOP_CENTER, n ? "12" : "XII");

          // Small Marks //
          it.print(getClkX(1), getClkY(1), id(small_font), TextAlign::CENTER, n ? "1" : "I");
          it.print(getClkX(2), getClkY(2), id(small_font), TextAlign::CENTER, n ? "2" : "II");
          it.print(getClkX(4), getClkY(4), id(small_font), TextAlign::CENTER, n ? "4" : "IV");
          it.print(getClkX(5), getClkY(5), id(small_font), TextAlign::CENTER, n ? "5" : "V");
          it.print(getClkX(7), getClkY(7), id(small_font), TextAlign::CENTER, n ? "7" : "VII");
          it.print(getClkX(8), getClkY(8), id(small_font), TextAlign::CENTER, n ? "8" : "VIII");
          it.print(getClkX(10), getClkY(10), id(small_font), TextAlign::CENTER, n ? "10" : "X");
          it.print(getClkX(11), getClkY(11), id(small_font), TextAlign::CENTER, n ? "11" : "XI");

          // Weather Temp //
          if (id(weather_temp_max) != -1000.0 && id(weather_age_hours) <= 12) {
            it.printf(w/2, h/2 - 30, id(small_font), TextAlign::BOTTOM_CENTER, "%.0f° to %.0f°", id(weather_temp_min), id(weather_temp_max));
          }

          // Date //
          it.strftime(w/2, h/2 + 30, id(small_font), TextAlign::TOP_CENTER, "%a %d %b", now);

          // Hour Hand //
          double hr = ((now.hour % 12 + now.minute / 60.0) / 12.0 * 360.0 - 90.0) * (M_PI / 180.0);
          for (int x=-2; x<=2; ++x) {
            for (int y=-2; y<=2; ++y) {
              it.line(w/2 +x, h/2 +y, w/2.0 + w/4.0 * cos(hr) +x, h/2.0 + h/4.0 * sin(hr) +y);
            }
          }

          // Minute Hand //
          double mn = (now.minute / 60.0 * 360.0 - 90.0) * (M_PI / 180.0);
          for (int x=-1; x<=1; ++x) {
            for (int y=-1; y<=1; ++y) {
              it.line(w/2 +x, h/2 +y, w/2.0 + w/2.5 * cos(mn) +x, h/2.0 + h/2.5 * sin(mn) +y);
            }
          }

          // Weather Icons //
          if (id(weather_age_hours) <= 3) {
            it.printf(w, 0, id(mdi), TextAlign::TOP_RIGHT, "%s", weatherIcons[rotateWeatherCode(0, now.hour, id(weather_code_0), id(weather_code_1), id(weather_code_2), id(weather_code_3))]);
          }
          if (id(weather_age_hours) <= 6) {
            it.printf(w, h, id(mdi), TextAlign::BOTTOM_RIGHT, "%s", weatherIcons[rotateWeatherCode(1, now.hour, id(weather_code_0), id(weather_code_1), id(weather_code_2), id(weather_code_3))]);
          }
          if (id(weather_age_hours) <= 9) {
            it.printf(0, h, id(mdi), TextAlign::BOTTOM_LEFT, "%s", weatherIcons[rotateWeatherCode(2, now.hour, id(weather_code_0), id(weather_code_1), id(weather_code_2), id(weather_code_3))]);
          }
          if (id(weather_age_hours) <= 12) {
            it.printf(0, 0, id(mdi), TextAlign::TOP_LEFT, "%s", weatherIcons[rotateWeatherCode(3, now.hour, id(weather_code_0), id(weather_code_1), id(weather_code_2), id(weather_code_3))]);
          }

          // Status Icons //
          it.printf(w*1/4, h/2, id(mdi_small), TextAlign::CENTER, "%s%s", chimeIcon, wifiIcon);
          it.printf(w*3/4, h/2, id(mdi_small), TextAlign::CENTER, "%s", batteryIcon);
          
        } else if (id(face) == 3) {
          ////////// System Info Face //////////

          if (id(weather_code_0) != 0) {
            it.printf(w/2, 0, id(mdi), TextAlign::TOP_CENTER, "%s%s%s%s%s",
              weatherIcons[id(weather_code_0)],
              weatherIcons[id(weather_code_1)],
              sky[random(skyLen)],
              weatherIcons[id(weather_code_2)],
              weatherIcons[id(weather_code_3)]
            );
          }

          int l = 38;
          const int lh = 18;
          const auto f = id(small_font);

          it.printf(0, l, f, TextAlign::TOP_LEFT, "%d:%02d", now.hour, now.minute);
          l += lh;

          it.strftime(0, l, f, TextAlign::TOP_LEFT , "%a %d %b", now);
          l += lh;

          if (id(weather_temp_max) != -1000.0) {
            it.printf(0, l, f, TextAlign::TOP_LEFT, "%.0f° to %.0f°", id(weather_temp_min), id(weather_temp_max));
          }
          l += lh;

          it.printf(0, l, f, TextAlign::TOP_LEFT,
            "Wifi: %s (%d)",
            (id(wifi_id).is_disabled() ? "off" : (id(wifi_id).is_connected() ? id(wifi_id).wifi_ssid().c_str() : "n/a")),
            (id(wifi_id).is_connected() ? id(wifi_id).wifi_rssi() : 0)
          );
          l += lh;

          it.print(0, l, f, TextAlign::TOP_LEFT, "ID: $ID");
          l += lh;

          it.printf(0, l, f, TextAlign::TOP_LEFT, "Battery: %.02fV", id(battery).state);
          l += lh;

          for (int x=-1*random(10); x<=w+20; x+=24) {
            it.printf(x, h+6, id(mdi), TextAlign::BOTTOM_LEFT, "%s", city[random(cityLen)]);
          }
        }
        
      } else if (id(mode) == $MODE_TIMERS) {
        it.printf(0, 0, id(mdi_small), TextAlign::TOP_LEFT, mdiTimerOutline);

        int l = 0;
        const int lh = 32;
        const auto f = id(date_font);

        it.printf(w/2, l, f, TextAlign::TOP_CENTER, "%d:%02d", now.hour, now.minute);
        l += lh * 1.8;

        const char *abcde = "ABCDE";

        for (int i=id(active_timer)+1; i<id(active_timer)+6; ++i) {
          int x = i % 5;
          if (id(timers)[x] != 0) {
            // Timer label:
            it.printf(0, l, id(small_font), TextAlign::CENTER_LEFT, "%c", abcde[x]);

            // Main timer:
            const int timer = utcnow.timestamp - id(timers)[x];
            const int timer_hrs = timer / (60*60);
            const int timer_min = (timer / 60) % 60;
            if (timer_hrs < 100) {
              it.printf(w/2+8, l, f, TextAlign::CENTER_RIGHT,
                "%2d:%02d",
                timer_hrs,
                timer_min
              );
            }

            // Split timer:
            int y = (x + 1) % 5; // Previous timer index
            if (id(timers)[y] != 0 && id(timers)[y] >= id(timers)[x]) {
              const int split = id(timers)[y] - id(timers)[x];
              const int split_hrs = split / (60*60);
              const int split_min = (split / 60) % 60;
              if (split_hrs < 100) {
                it.printf(w, l, f, TextAlign::CENTER_RIGHT,
                  "%2d:%02d",
                  split_hrs,
                  split_min
                );
              }
            }

            l += lh;
          }
        }

        // Wifi status //
        it.printf(w, 0, id(mdi_small), TextAlign::TOP_RIGHT, "%s", wifiIcon);

      } else if (id(mode) == $MODE_HA) {
        it.print(0, 0, id(mdi_small), TextAlign::TOP_LEFT, mdiHomeAssistant);

        int l = 0;
        const int lh = 34;
        const int lo = 38;

        it.printf(w/2, l, id(date_font), TextAlign::TOP_CENTER, "%d:%02d", now.hour, now.minute);
        l += lh * 1.5;

        it.print(0, l, id(small_font), TextAlign::CENTER_LEFT, "Add your code here.");
        l += lh;

        // Wifi status //
        it.printf(w, 0, id(mdi_small), TextAlign::TOP_RIGHT, "%s", wifiIcon);

      } else if (id(mode) >= 1000) {
        id(mode) = id(mode) - 1000;
        it.print(w/2, h/2, id(date_font), TextAlign::BOTTOM_CENTER, "DON'T");
        it.print(w/2, h/2, id(date_font), TextAlign::TOP_CENTER, "PANIC");

      } else if (id(mode) == $MODE_QR) {
        auto qr = id(qr_vcard);
        const char *qrModeIcon = mdiAccountBox;

        if (id(qr_mode) == 1) {
          qr = id(qr_website);
          qrModeIcon = mdiWebBox;
        } else if (id(qr_mode) == 2) {
          qr = id(qr_rss);
          qrModeIcon = mdiRssBox;
        }

        const int offset = 18;
        const auto size = qr->get_size();
        const int scale = int(float(w - offset) / float(size));
        const auto x = (w / 2) - ((size * scale) / 2);
        const auto y = ((h - offset) / 2) - ((size * scale) / 2) + offset;

        it.print(0, 0, id(mdi_small), TextAlign::TOP_LEFT, qrModeIcon);
        it.printf(w/2, -2, id(small_font), TextAlign::TOP_CENTER, "%d:%02d", now.hour, now.minute);
        it.printf(w, 0, id(mdi_small), TextAlign::TOP_RIGHT, "%s", wifiIcon);
        it.qr_code(x, y, qr, Color(255,255,255), scale);
      }

binary_sensor:
  # https://esphome.io/components/binary_sensor

  ## Left Top ##

  - id: power_on_button
    pin:
      number: $BUTTON_LEFT_TOP_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    on_click:
      min_length: 0ms
      max_length: 1s
      then:
        - lambda: |-
            id(counter) = 0;
            id(updating_weather) = true;
            id(updating_time) = true;
            id(wifi_id).enable();
        - component.update: glass

  - id: deep_sleep_button
    pin:
      number: $BUTTON_LEFT_TOP_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    filters:
      delayed_on: 1s
    on_press:
      - wifi.disable:
      - lambda: id(keep_awake) = false;
      - component.update: glass
      - delay: 100ms
      - deep_sleep.enter:

  ## Left Bottom ##

  - id: timer_button
    pin:
      number: $BUTTON_LEFT_BOTTOM_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    on_click:
      min_length: 0ms
      max_length: 1s
      then:
        - lambda: |-
            id(counter) = 0;
            id(mode) = $MODE_TIMERS;
            id(active_timer) = (id(active_timer) + 1) % 5;
            id(timers)[id(active_timer)] = id(ntp).utcnow().timestamp;
        - component.update: glass

  - id: cancel_active_timer_button
    pin:
      number: $BUTTON_LEFT_BOTTOM_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    filters:
      delayed_on: 1s
    on_press:
      - lambda: |-
          id(counter) = 0;
          id(mode) = $MODE_TIMERS;
          id(timers)[id(active_timer)] = 0;
          if (id(active_timer) != 0) {
            id(active_timer) -= 1;
          }
      - component.update: glass

  - id: clear_all_timers_button
    pin:
      number: $BUTTON_LEFT_BOTTOM_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    filters:
      delayed_on: 2s
    on_press:
      - lambda: |-
          id(counter) = 0;
          id(mode) = $MODE_TIMERS;
          id(active_timer) = 0;
          id(timers)[0] = id(ntp).utcnow().timestamp;
          id(timers)[1] = 0;
          id(timers)[2] = 0;
          id(timers)[3] = 0;
          id(timers)[4] = 0;
      - component.update: glass

  ## Right Top ##

  - id: face_cycle_button
    pin:
      number: $BUTTON_RIGHT_TOP_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    on_click:
      min_length: 0ms
      max_length: 1s
      then:
        - lambda: |-
            id(counter) = 0;
            if (id(mode) == $MODE_FACES) {
              id(face) = (id(face) + 1) % $FACE_COUNT;
            } else {
              id(mode) = $MODE_FACES;
            }
        - component.update: glass

  - id: epaper_display_clean_refresh_button
    pin:
      number: $BUTTON_RIGHT_TOP_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    filters:
      delayed_on: 1s
    on_press:
      - lambda: |-
          id(counter) = 0;
          // ePaper full wipe clean:
          id(glass).set_full_update_every(1);
          id(glass).update();
          id(glass).set_full_update_every(1000);
          id(glass).update();

  ## Right Bottom ##

  - id: ha_qr_mode_button
    pin:
      number: $BUTTON_RIGHT_BOTTOM_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    on_click:
      min_length: 0ms
      max_length: 1s
      then:
        - lambda: |-
            id(counter) = 0;
            if (id(mode) == $MODE_QR) {
              id(qr_mode) = (id(qr_mode) + 1) % 3;
            } else {
              id(mode) = $MODE_HA;
            }
        - component.update: glass

  - id: qr_codes_mode_button
    pin:
      number: $BUTTON_RIGHT_BOTTOM_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    filters:
      delayed_on: 1s
    on_press:
      - lambda: |-
          id(counter) = 0;
          id(mode) = $MODE_QR;
      - component.update: glass

  ## Charging ##

  - id: is_charging
    pin:
      # number: $CHRG_STATUS_PIN # Does not seem to work
      number: $USB_DET_PIN
    platform: gpio

wifi:
  # https://esphome.io/components/wifi.html
  id: wifi_id
  power_save_mode: HIGH
  enable_on_boot: false
  ssid: $WIFI_SSID
  password: $WIFI_PASSWORD
  fast_connect: true
  reboot_timeout: 0s
  on_connect:
    - component.update: glass
    - lambda: |-
        if (id(updating_time)) {
          id(ntp).update();
        }
    - if:
        condition:
          lambda: return id(updating_weather) || id(weather_age) == 0 || id(weather_age_hours) >= 3;
        then:
          script.execute: update_weather

script:
  - id: update_weather
    mode: single
    then:
      - lambda: ESP_LOGI("watchy", "Weather HTTP request.");
      - http_request.get:
          url: http://api.openweathermap.org/data/2.5/forecast?cnt=4&id=$WEATHER_CITY_ID&units=$UNITS&lang=$LANG&appid=$WEATHER_KEY
          headers:
            Content-Type: application/json
          capture_response: true
          max_response_buffer_size: 3kB
          on_response:
            then:
              - lambda: |-
                  // ESP_LOGI("watchy", "Weather status %d %ums.", status_code, duration_ms);

                  json::parse_json(body, [](JsonObject root) -> bool {
                    id(weather_age) = id(ntp).now().timestamp;
                    id(weather_age_hours) = 0;

                    id(weather_code_0) = weatherCode(root["list"][0]["weather"][0]["id"], root["list"][0]["sys"]["pod"]);
                    id(weather_code_1) = weatherCode(root["list"][1]["weather"][0]["id"], root["list"][1]["sys"]["pod"]);
                    id(weather_code_2) = weatherCode(root["list"][2]["weather"][0]["id"], root["list"][2]["sys"]["pod"]);
                    id(weather_code_3) = weatherCode(root["list"][3]["weather"][0]["id"], root["list"][3]["sys"]["pod"]);

                    float tMin = 99.0;
                    float tMax = -99.0;
                    for (int x=0; x<=3; ++x) {
                      tMin = min(tMin, float(root["list"][x]["main"]["temp_min"]));
                      tMax = max(tMax, float(root["list"][x]["main"]["temp_max"]));
                    }
                    id(weather_temp_min) = tMin;
                    id(weather_temp_max) = tMax;

                    return true;
                  });

                  id(updating_weather) = false;

                  if (!id(updating_time)) {
                    id(glass).set_full_update_every(1);
                  }
                  id(glass).update();
              - script.execute: go_to_sleep

  - id: go_to_sleep
    mode: restart
    then:
      if:
        condition:
          lambda: return !id(updating_time) && !id(updating_weather) && !id(keep_awake);
        then:
          deep_sleep.enter:
        else:
          lambda: |-
            id(glass).set_full_update_every(1000); // reset epaper full wipe clean

  - id: deep_sleep_enter
    mode: restart
    then:
      deep_sleep.enter:
        sleep_duration: !lambda |-
          const auto now = id(ntp).now();

          if (id(battery).state < $BATTERY_LOW) {
            // Sleep up to 10 min:
            ESP_LOGE("watchy", "Sleep 10min");
            return ((10 - (now.minute % 10)) * 60 - now.second) * 1000;
          }

          if (id(battery).state < $BATTERY_HIGH) {
            // Sleep up to 5 min:
            ESP_LOGE("watchy", "Sleep 5min");
            return ((5 - (now.minute % 5)) * 60 - now.second) * 1000;
          }

          // Sleep 1 min:
          ESP_LOGE("watchy", "Sleep 1min");
          return 60 * 1000; // - now.second;

time:
  ## https://esphome.io/components/time/sntp
  - id: ntp
    platform: sntp
    timezone: $TIME_ZONE
    on_time_sync:
      if:
        condition:
          - wifi.connected:
          - lambda: "return id(ntp).now().is_valid();"
        then:
          # - pcf8563.write_time:
          - lambda: |-
              id(updating_time) = false;
              if (id(updating_time) && !id(updating_weather)) {
                id(glass).set_full_update_every(1);
              }
              id(glass).update();
          - script.execute: go_to_sleep
    on_time:
      - seconds: 0
        then:
          - lambda: id(counter) += 1;
          - if:
              condition:
                lambda: return id(keep_awake);
              then:
                - if:
                    condition:
                      lambda: return id(counter) <= 5;
                    then:
                      component.update: glass
                    else:
                      - wifi.disable:
                      - component.update: glass
                      - deep_sleep.enter:
              else:
                - if:
                    condition:
                      lambda: return id(counter) > 2;
                    then:
                      deep_sleep.enter:

  ## Only for v2
  ## https://esphome.io/components/time/
  ## https://esphome.io/components/time/pcf8563.html
  # - platform: pcf8563
  #   id: pcf
  #   update_interval: never
  #   address: 0x51

deep_sleep:
  # https://esphome.io/components/deep_sleep.html
  sleep_duration: 60sec
  wakeup_pin_mode: INVERT_WAKEUP
  wakeup_pin:
    number: $BUTTON_LEFT_TOP_PIN
    inverted: $BUTTON_PIN_INVERTED
    allow_other_uses: true

globals:
  - id: counter
    type: int
    initial_value: "0"
  - id: keep_awake
    type: boolean
    initial_value: "false"
  - id: updating_time
    type: boolean
    initial_value: "false"
  - id: updating_weather
    type: boolean
    initial_value: "false"
  - id: weather_age_hours
    type: int
    initial_value: "0"
  - id: chime
    type: boolean
    initial_value: "false"
  ## Persistent ##
  - id: face
    type: int
    restore_value: yes
    initial_value: "0"
  - id: mode
    type: int
    restore_value: yes
    initial_value: "0"
  - id: qr_mode
    type: int
    restore_value: yes
    initial_value: "0"
  - id: weather_age
    type: int
    restore_value: yes
    initial_value: "0"
  - id: weather_code_0
    type: int
    restore_value: yes
    initial_value: "0"
  - id: weather_code_1
    type: int
    restore_value: yes
    initial_value: "0"
  - id: weather_code_2
    type: int
    restore_value: yes
    initial_value: "0"
  - id: weather_code_3
    type: int
    restore_value: yes
    initial_value: "0"
  - id: weather_temp_min
    type: float
    restore_value: yes
    initial_value: "99.0"
  - id: weather_temp_max
    type: float
    restore_value: yes
    initial_value: "-99.0"
  - id: active_timer
    type: int
    restore_value: yes
    initial_value: "0"
  - id: timers
    type: int[5]
    restore_value: yes

font:
  # https://freefonts.co/fonts/futura-bold
  # https://github.com/Templarian/MaterialDesign-Webfont/tree/master/fonts

  - id: small_font
    file: "fonts/Futura Bold/Futura Bold.otf"
    size: 16
    glyphs: "().:°'-/0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz"

  - id: date_font
    file: "fonts/Futura Bold/Futura Bold.otf"
    size: 28
    glyphs: ":°'-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz"

  - id: time_font
    file: "fonts/Futura Bold/Futura Bold.otf"
    size: 64
    glyphs: ":0123456789"

  - file: fonts/mdi/fonts/materialdesignicons-webfont.woff
    id: mdi_small
    size: 24
    glyphs:
      - "$mdiEmoticonHappyOutline"
      - "$mdiWifi"
      - "$mdiWifiOff"
      - "$mdiBellRingOutline"
      - "$mdiBatteryCharging100"
      - "$mdiBattery"
      - "$mdiBattery70"
      - "$mdiBattery30"
      - "$mdiBattery10"
      - "$mdiBatteryUnknown"
      - "$mdiAccountBox"
      - "$mdiWebBox"
      - "$mdiRssBox"
      - "$mdiTimerOutline"
      - "$mdiHomeAssistant"

  - id: mdi
    file: fonts/mdi/fonts/materialdesignicons-webfont.woff
    size: 36
    glyphs:
      # Weather:
      - "$mdiAlert"
      - "$mdiWeatherCloudy"
      - "$mdiWeatherCloudyAlert"
      - "$mdiWeatherCloudyArrowRight"
      - "$mdiWeatherDust"
      - "$mdiWeatherFog"
      - "$mdiWeatherHail"
      - "$mdiWeatherHazy"
      - "$mdiWeatherHurricane"
      - "$mdiWeatherLightning"
      - "$mdiWeatherLightningRainy"
      - "$mdiWeatherNight"
      - "$mdiWeatherNightPartlyCloudy"
      - "$mdiWeatherPartlyCloudy"
      - "$mdiWeatherPartlyLightning"
      - "$mdiWeatherPartlyRainy"
      - "$mdiWeatherPartlySnowy"
      - "$mdiWeatherPartlySnowyRainy"
      - "$mdiWeatherPouring"
      - "$mdiWeatherRainy"
      - "$mdiWeatherSnowy"
      - "$mdiWeatherSnowyHeavy"
      - "$mdiWeatherSnowyRainy"
      - "$mdiWeatherSunny"
      - "$mdiWeatherSunnyAlert"
      - "$mdiWeatherSunnyOff"
      - "$mdiWeatherSunset"
      - "$mdiWeatherSunsetDown"
      - "$mdiWeatherSunsetUp"
      - "$mdiWeatherTornado"
      - "$mdiWeatherWindy"
      - "$mdiWeatherWindyVariant"
      # City:
      - "$mdiCity"
      - "$mdiCityVariant"
      - "$mdiOfficeBuilding"
      - "$mdiCastle"
      - "$mdiGoogleDownasaur"
      - "$mdiPineTree"
      # Sky:
      - "$mdiStarOutline"
      - "$mdiStarShootingOutline"
      - "$mdiCreationOutline"
      - "$mdiHelicopter"
      - "$mdiAirballoon"
      - "$mdiBird"
      - "$mdiSpaceInvaders"
      - "$mdiSpaceStation"
      - "$mdiUfoOutline"
      - "$mdiSatelliteVariant"
      # Dates:
      - "$mdiBee"
      - "$mdiBicycle"
      - "$mdiCakeVariantOutline"
      - "$mdiClover"
      - "$mdiCodeBraces"
      - "$mdiDeathStarVariant"
      - "$mdiDebugStepOver"
      - "$mdiDonkey"
      - "$mdiEarth"
      - "$mdiElephant"
      - "$mdiEmoticonHappyOutline"
      - "$mdiFerry"
      - "$mdiForest"
      - "$mdiHalloween"
      - "$mdiHeart"
      - "$mdiHospitalBuilding"
      - "$mdiHumanMaleBoard"
      - "$mdiHumanMaleChild"
      - "$mdiLinkBoxVariant"
      - "$mdiPartyPopper"
      - "$mdiPeace"
      - "$mdiPlusThick"
      - "$mdiRocketLaunch"
      - "$mdiSchool"
      - "$mdiTeddyBear"
      - "$mdiVote"
      - "$mdiWater"

esp32:
  board: esp32-s3-devkitc-1
  ## https://raw.githubusercontent.com/espressif/arduino-esp32/master/tools/partitions/default_8MB.csv
  flash_size: 8MB
  partitions: default_8MB.csv
  variant: esp32s3

logger:
  level: ERROR

sensor:
  - platform: adc
    ## https://esphome.io/components/sensor/adc.html#esp32-pins
    ## What does this mean!?:
    ## "ADC2 pins are only usable when Wi-Fi is not configured on the device."
    attenuation: auto
    pin: $BATT_ADC_PIN
    id: battery
    update_interval: never
    filters:
      - multiply: $ADC_VOLTAGE_DIVIDER

switch:
  - id: buzzer
    pin: $VIB_MOTOR_PIN
    platform: gpio

i2c:
  scan: false
  sda: $I2C_SDA_PIN
  scl: $I2C_SCL_PIN

spi:
  # SPI_SS_PIN ??
  mosi_pin: $SPI_MOSI_PIN
  miso_pin: $SPI_MISO_PIN
  clk_pin: $SPI_SCK_PIN

sun:
  id: sol
  latitude: $LATITUDE
  longitude: $LONGITUDE

ota:
  password: $OTA_PASSWORD
  platform: esphome

http_request:
  id: http_request_data
  verify_ssl: false

qr_code:
  - id: qr_vcard
    ecc: LOW
    value: $QR_VCARD

  - id: qr_website
    ecc: LOW
    value: $QR_WEBSITE_URL

  - id: qr_rss
    ecc: LOW
    value: $QR_RSS_URL

external_components:
  - components: [waveshare_epaper]
    source:
      # type: local
      # path: ../esphome/esphome/components
      type: git
      url: https://github.com/multipolygon/esphome
      ref: dev



